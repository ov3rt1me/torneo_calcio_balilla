<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Torneo</title>
  <style>
    :root{
      --bg:#0f1220;
      --card:#171a2b;
      --muted:#9aa3b2;
      --text:#e9eef7;
      --line:rgba(255,255,255,.08);
      --win:#1ed760;
      --lose:#ff4d4d;
      --gold:#d4af37;
      --silver:#c0c0c0;
      --bronze:#cd7f32;
      --accent:#6aa6ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 600px at 20% 0%, rgba(106,166,255,.18), transparent 60%),
                  radial-gradient(1000px 600px at 80% 10%, rgba(30,215,96,.12), transparent 60%),
                  var(--bg);
      color:var(--text);
    }
    header{
      padding:20px 16px 12px;
      border-bottom:1px solid var(--line);
      position:sticky; top:0; background:rgba(15,18,32,.82); backdrop-filter: blur(10px);
      z-index:10;
    }
    .wrap{max-width:1100px; margin:0 auto;}
    .toprow{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;}
    h1{margin:0; font-size:20px; letter-spacing:.3px;}
    .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    select, button{
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--text);
      padding:8px 10px;
      border-radius:10px;
      outline:none;
    }
    button{cursor:pointer}
    button:hover{border-color:rgba(255,255,255,.18)}
    .hint{color:var(--muted); font-size:12px; margin-top:8px}
    main{padding:18px 16px 30px}
    .grid{display:grid; grid-template-columns: 1.05fr .95fr; gap:14px;}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr;} }

    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.20);
    }
    .card h2{margin:0 0 10px; font-size:16px; color:#f2f5ff}
    .sub{color:var(--muted); font-size:12px; margin-top:-4px; margin-bottom:10px}

    table{width:100%; border-collapse:collapse; font-size:13px;}
    th, td{padding:8px 6px; border-bottom:1px solid var(--line); text-align:left; vertical-align:middle;}
    th{color:#cfd7e6; font-weight:600; font-size:12px; letter-spacing:.3px;}
    tr:hover td{background:rgba(255,255,255,.03)}
    .pos{width:34px; color:#cfd7e6}
    .teamcell{display:flex; align-items:center; gap:10px;}
    .logo{width:28px; height:28px; object-fit:contain; border-radius:6px; background:rgba(255,255,255,.04); padding:3px; border:1px solid rgba(255,255,255,.06)}
    .medal{font-size:14px; margin-left:6px}
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 8px; border-radius:999px;
      border:1px solid var(--line); background:rgba(255,255,255,.04);
      font-size:12px; color:#dfe6f5;
    }

    .matchlist{display:flex; flex-direction:column; gap:10px;}
    .match{
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      gap:10px;
      align-items:center;
      padding:10px 10px;
      border:1px solid var(--line);
      border-radius:14px;
      background:rgba(255,255,255,.04);
    }
    .side{
      display:flex; align-items:center; gap:10px;
      min-width:0;
    }
    .side.right{justify-content:flex-end}
    .tname{white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .score{
      min-width:80px;
      text-align:center;
      font-weight:700;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
    }
    .phase{
      font-size:11px; color:var(--muted);
      margin:0 0 8px;
    }
    .hl-win{box-shadow:0 0 0 2px rgba(30,215,96,.25) inset;}
    .hl-lose{box-shadow:0 0 0 2px rgba(255,77,77,.22) inset;}
    .pill-win{color:#062812; background:rgba(30,215,96,.95); border-color:rgba(30,215,96,.1)}
    .pill-lose{color:#2b0b0b; background:rgba(255,77,77,.92); border-color:rgba(255,77,77,.1)}
    .note{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.4}

    .legend{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    .legend .badge{opacity:.95}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="toprow">
      <h1>Tabellone torneo</h1>
      <div class="controls">
        <label class="badge">Girone
          <select id="groupSelect" title="Seleziona girone"></select>
        </label>
        <button id="reloadBtn" title="Ricarica result.csv">Ricarica</button>
      </div>
    </div>
    <div class="hint">
      Legge i dati da <b>result.csv</b>. Loghi: <b>loghi/NomeSquadra.png</b> (nome identico a quello nel CSV).
    </div>
  </div>
</header>

<main>
  <div class="wrap grid">
    <section class="card">
      <h2>Classifica girone</h2>
      <div class="sub" id="standingsSub">Calcolo automatico da fase a gironi</div>
      <div style="overflow:auto">
        <table id="standingsTable">
          <thead>
            <tr>
              <th class="pos">#</th>
              <th>Squadra</th>
              <th>G</th>
              <th>V</th>
              <th>P</th>
              <th>PF</th>
              <th>PS</th>
              <th>Diff</th>
              <th>Pt</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="legend">
        <span class="badge">ðŸ¥‡ 1Â°</span>
        <span class="badge">ðŸ¥ˆ 2Â°</span>
        <span class="badge">ðŸ¥‰ 3Â°</span>
        <span class="badge">ðŸ’€ ultimo</span>
      </div>
      <div class="note">
        <b>Punti:</b> vittoria = 2, sconfitta = 0. <b>Diff</b> = PF - PS.
        (Se nel tuo regolamento i punti sono diversi, dimmelo e lo adatto.)
      </div>
    </section>

    <section class="card">
      <h2>Fase finale</h2>
      <p class="phase">Semifinali e finale vengono <b>auto-compilate</b> usando la classifica del girone selezionato (1vs4 e 2vs3).</p>
      <div class="matchlist" id="knockoutList"></div>
      <div class="note">
        Inserisci i risultati di <b>Semifinali / Finale / Playout</b> nelle righe in fondo al CSV.
        Quando c'Ã¨ l'<b>Aggregato</b> (es. 2-1), evidenziamo vincitore e perdente, e mettiamo le medaglie.
      </div>
    </section>
  </div>
</main>

<script>
const CSV_URL = 'result.csv';

function safe(s){ return (s ?? '').toString().trim(); }

function logoSrc(team){
  // se hai estensioni diverse, puoi aggiungere fallback qui (es: .jpg)
  return `loghi/${encodeURIComponent(team)}.png`;
}

function parseAgg(agg){
  // agg tipo "2-0" oppure "1-2"
  const m = safe(agg).match(/^\s*(\d+)\s*-\s*(\d+)\s*$/);
  if(!m) return null;
  return {a: parseInt(m[1],10), b: parseInt(m[2],10)};
}

function winnerFromAgg(teamA, teamB, agg){
  const p = parseAgg(agg);
  if(!p) return null;
  if(p.a === p.b) return {winner:null, loser:null, draw:true};
  return (p.a > p.b)
    ? {winner:teamA, loser:teamB, draw:false}
    : {winner:teamB, loser:teamA, draw:false};
}

function groupKey(teams){
  // chiave deterministica per raggruppare le squadre in "gironi" in base ai match
  return [...teams].sort().join('|');
}

function computeStandings(matches, groupTeams){
  const stats = {};
  for(const t of groupTeams){
    stats[t] = {team:t, g:0, w:0, l:0, pf:0, ps:0, diff:0, pt:0};
  }

  for(const m of matches){
    const a = m.s1, b = m.s2;
    if(!(a in stats) || !(b in stats)) continue;

    // prendo gol/points dal csv se presenti, altrimenti provo dall'Aggregato (set) solo per decidere winner/loser
    const g1 = Number.isFinite(m.g1) ? m.g1 : 0;
    const g2 = Number.isFinite(m.g2) ? m.g2 : 0;

    // esito: 'A' vince squadra1, 'B' vince squadra2 (come nel tuo csv)
    const es = safe(m.esito).toUpperCase();
    const played = (es === 'A' || es === 'B') || (!!safe(m.agg) && !!parseAgg(m.agg));

    if(!played) continue;

    stats[a].g += 1;
    stats[b].g += 1;

    // punti fatti/subiti
    stats[a].pf += g1;
    stats[a].ps += g2;
    stats[b].pf += g2;
    stats[b].ps += g1;

    // winner
    let winner = null;
    if(es === 'A') winner = a;
    if(es === 'B') winner = b;
    if(!winner){
      const wb = winnerFromAgg(a,b,m.agg);
      if(wb && !wb.draw) winner = wb.winner;
    }

    if(winner === a){
      stats[a].w += 1; stats[b].l += 1;
      stats[a].pt += 2;
    }else if(winner === b){
      stats[b].w += 1; stats[a].l += 1;
      stats[b].pt += 2;
    }
  }

  const arr = Object.values(stats);
  for(const s of arr){ s.diff = s.pf - s.ps; }
  // ordinamento: punti, diff, PF, nome
  arr.sort((x,y)=> (y.pt-x.pt) || (y.diff-x.diff) || (y.pf-x.pf) || x.team.localeCompare(y.team));
  return arr;
}

function renderStandings(standings){
  const tbody = document.querySelector('#standingsTable tbody');
  tbody.innerHTML = '';
  standings.forEach((s, idx)=>{
    const tr = document.createElement('tr');
    const medal = (idx===0) ? 'ðŸ¥‡' : (idx===1) ? 'ðŸ¥ˆ' : (idx===2) ? 'ðŸ¥‰' : (idx===standings.length-1) ? 'ðŸ’€' : '';
    tr.innerHTML = `
      <td class="pos">${idx+1}</td>
      <td>
        <div class="teamcell">
          <img class="logo" src="${logoSrc(s.team)}" alt="${s.team}" onerror="this.style.opacity=.25; this.style.filter='grayscale(1)';">
          <div class="tname">${s.team}${medal ? `<span class="medal">${medal}</span>`:''}</div>
        </div>
      </td>
      <td>${s.g}</td>
      <td>${s.w}</td>
      <td>${s.l}</td>
      <td>${s.pf}</td>
      <td>${s.ps}</td>
      <td>${s.diff}</td>
      <td><b>${s.pt}</b></td>
    `;
    tbody.appendChild(tr);
  });
}

function matchCard({phase, a, b, agg, highlightWinner=null, highlightLoser=null, medalText=null}){
  const div = document.createElement('div');
  div.className = 'match';
  let pillClass = '';
  let cardClass = '';
  if(highlightWinner && highlightWinner === a) cardClass = 'hl-win';
  if(highlightWinner && highlightWinner === b) cardClass = 'hl-win';
  if(highlightLoser && (highlightLoser === a || highlightLoser === b)) cardClass = 'hl-lose';
  if(highlightWinner && highlightWinner && highlightWinner !== null) pillClass = 'pill-win';
  if(highlightLoser && highlightLoser && highlightLoser !== null) pillClass = 'pill-lose';

  div.className = 'match ' + ( (highlightWinner||highlightLoser) ? (highlightWinner ? 'hl-win' : 'hl-lose') : '');

  const scoreText = (safe(agg) ? safe(agg) : '-');
  const scorePillClass = highlightWinner ? 'pill-win' : (highlightLoser ? 'pill-lose' : '');

  div.innerHTML = `
    <div class="side left">
      <img class="logo" src="${logoSrc(a)}" alt="${a}" onerror="this.style.opacity=.25; this.style.filter='grayscale(1)';">
      <div class="tname">${a}</div>
    </div>
    <div class="score ${scorePillClass}" title="Aggregato (es. 2-1)">${scoreText}${medalText ? ` ${medalText}`:''}</div>
    <div class="side right">
      <div class="tname">${b}</div>
      <img class="logo" src="${logoSrc(b)}" alt="${b}" onerror="this.style.opacity=.25; this.style.filter='grayscale(1)';">
    </div>
  `;
  return div;
}

function getGroupSetsFromMatches(groupMatches){
  const teams = new Set();
  for(const m of groupMatches){ teams.add(m.s1); teams.add(m.s2); }
  return teams;
}

function splitIntoGroups(groupStageMatches){
  // Raggruppa per "insieme di squadre" connesso (componenti connesse nel grafo dei match)
  const graph = new Map();
  function addEdge(u,v){
    if(!graph.has(u)) graph.set(u,new Set());
    if(!graph.has(v)) graph.set(v,new Set());
    graph.get(u).add(v);
    graph.get(v).add(u);
  }
  for(const m of groupStageMatches){ addEdge(m.s1,m.s2); }

  const visited = new Set();
  const groups = [];
  for(const node of graph.keys()){
    if(visited.has(node)) continue;
    const stack=[node];
    visited.add(node);
    const comp=new Set([node]);
    while(stack.length){
      const u=stack.pop();
      for(const v of graph.get(u)||[]){
        if(!visited.has(v)){
          visited.add(v);
          stack.push(v);
          comp.add(v);
        }
      }
    }
    groups.push(comp);
  }

  // Ordina gruppi per dimensione desc
  groups.sort((a,b)=>b.size-a.size);
  return groups;
}

function extractMatches(csvText){
  const lines = csvText.split(/\r?\n/).filter(l=>l.trim().length>0);
  const header = lines.shift(); // unused
  const matches = [];
  for(const line of lines){
    const c = line.split(';');
    // garantisco 7 campi
    while(c.length<7) c.push('');
    const s1 = safe(c[0]);
    const s2 = safe(c[1]);
    if(!s1 || !s2) continue;

    // KO rows are those starting with "Semifinale", "Finale", "Playout"
    const isKO = /^semifinale|^finale|^playout/i.test(s1);

    const g1 = safe(c[2])==='' ? NaN : parseInt(c[2],10);
    const g2 = safe(c[3])==='' ? NaN : parseInt(c[3],10);
    matches.push({
      raw: line,
      s1, s2,
      g1, g2,
      esito: safe(c[4]),
      txt: safe(c[5]),
      agg: safe(c[6]),
      isKO
    });
  }
  return matches;
}

function findKoRow(matches, prefix){
  // prende la riga KO in base al nome Squadra1
  const re = new RegExp('^' + prefix.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'), 'i');
  return matches.find(m=>m.isKO && re.test(m.s1)) || null;
}

function normalizeTeamNameFromPlaceholder(s){
  // "Semifinale 1 - Squadra 1" -> placeholder
  return s;
}

function renderKnockout(standings, koMatches){
  const list = document.getElementById('knockoutList');
  list.innerHTML = '';

  if(standings.length < 4){
    const p = document.createElement('div');
    p.className = 'note';
    p.textContent = 'Servono almeno 4 squadre nel girone selezionato per calcolare le semifinali.';
    list.appendChild(p);
    return;
  }

  const first = standings[0].team;
  const second = standings[1].team;
  const third = standings[2].team;
  const fourth = standings[3].team;
  const last = standings[standings.length-1].team;
  const secondLast = standings[standings.length-2]?.team;

  // auto-seeding
  const sf1 = {a:first, b:fourth, row: findKoRow(koMatches, 'Semifinale 1')};
  const sf2 = {a:second, b:third, row: findKoRow(koMatches, 'Semifinale 2')};
  const finalRow = findKoRow(koMatches, 'Finale');

  // playout: bottom 2, due match (Playout 1 e Playout 2)
  const pl1 = {a:secondLast || '-', b:last || '-', row: findKoRow(koMatches, 'Playout 1')};
  const pl2 = {a:secondLast || '-', b:last || '-', row: findKoRow(koMatches, 'Playout 2')};

  // Decide winners if results exist
  const sf1Res = sf1.row ? winnerFromAgg(sf1.row.s1, sf1.row.s2, sf1.row.agg) : null;
  const sf2Res = sf2.row ? winnerFromAgg(sf2.row.s1, sf2.row.s2, sf2.row.agg) : null;

  // Who goes to final? If the CSV has real team names in Finale row, trust them; otherwise infer from semifinals.
  let finalA = finalRow ? finalRow.s1 : 'Finale - Squadra 1';
  let finalB = finalRow ? finalRow.s2 : 'Finale - Squadra 2';

  const finaleHasPlaceholders = finalRow && (/^finale\s*-\s*squadra/i.test(finalRow.s1) || /^finale\s*-\s*squadra/i.test(finalRow.s2));

  if(!finalRow || finaleHasPlaceholders){
    const w1 = sf1Res && sf1Res.winner ? sf1Res.winner : sf1.a;
    const w2 = sf2Res && sf2Res.winner ? sf2Res.winner : sf2.a;
    finalA = w1;
    finalB = w2;
  }

  // Final winner and medal highlight
  const finalRes = finalRow ? winnerFromAgg(finalRow.s1, finalRow.s2, finalRow.agg) : null;
  let champion = null;
  if(finalRes && finalRes.winner) champion = finalRes.winner;

  // Last place from Playout 2 (the "finale ultimo posto")
  const pl2Res = pl2.row ? winnerFromAgg(pl2.row.s1, pl2.row.s2, pl2.row.agg) : null;
  let lastPlace = null;
  if(pl2Res && pl2Res.loser) lastPlace = pl2Res.loser; // loser is ultimo

  // Build cards with highlights + medals
  list.appendChild(matchCard({
    phase:'Semifinale 1',
    a: sf1.row ? sf1.row.s1 : sf1.a,
    b: sf1.row ? sf1.row.s2 : sf1.b,
    agg: sf1.row ? sf1.row.agg : '',
    highlightWinner: (sf1Res && sf1Res.winner) ? sf1Res.winner : null,
    highlightLoser:  (sf1Res && sf1Res.loser) ? sf1Res.loser : null
  }));

  list.appendChild(matchCard({
    phase:'Semifinale 2',
    a: sf2.row ? sf2.row.s1 : sf2.a,
    b: sf2.row ? sf2.row.s2 : sf2.b,
    agg: sf2.row ? sf2.row.agg : '',
    highlightWinner: (sf2Res && sf2Res.winner) ? sf2Res.winner : null,
    highlightLoser:  (sf2Res && sf2Res.loser) ? sf2Res.loser : null
  }));

  // Final card, show ðŸ¥‡ to winner if exists
  let medalText = '';
  if(champion){
    medalText = 'ðŸ¥‡';
  }

  list.appendChild(matchCard({
    phase:'Finale',
    a: finalRow ? finalRow.s1 : finalA,
    b: finalRow ? finalRow.s2 : finalB,
    agg: finalRow ? finalRow.agg : '',
    highlightWinner: champion,
    highlightLoser: (finalRes && finalRes.loser) ? finalRes.loser : null,
    medalText
  }));

  // Playout cards
  list.appendChild(matchCard({
    phase:'Playout 1',
    a: pl1.row ? pl1.row.s1 : pl1.a,
    b: pl1.row ? pl1.row.s2 : pl1.b,
    agg: pl1.row ? pl1.row.agg : '',
    highlightWinner: null,
    highlightLoser: null
  }));

  // Playout 2 (ultimo posto): mark loser with ðŸ’€ and red pill
  let lastMedal = '';
  let pl2Winner = null;
  let pl2Loser = null;
  if(pl2Res && !pl2Res.draw){
    pl2Winner = pl2Res.winner;
    pl2Loser = pl2Res.loser;
    lastMedal = 'ðŸ’€';
  }
  list.appendChild(matchCard({
    phase:'Playout 2 (ultimo posto)',
    a: pl2.row ? pl2.row.s1 : pl2.a,
    b: pl2.row ? pl2.row.s2 : pl2.b,
    agg: pl2.row ? pl2.row.agg : '',
    highlightWinner: pl2Winner,
    highlightLoser: pl2Loser,
    medalText: lastMedal
  }));
}

async function loadAll(){
  const res = await fetch(CSV_URL, {cache:'no-store'});
  const txt = await res.text();
  const allMatches = extractMatches(txt);

  const groupStage = allMatches.filter(m=>!m.isKO);
  const ko = allMatches.filter(m=>m.isKO);

  // gruppi per componenti connesse
  const comps = splitIntoGroups(groupStage);
  const groupSelect = document.getElementById('groupSelect');
  const previous = groupSelect.value;

  // populate select
  groupSelect.innerHTML = '';
  const labeled = comps.map((set, idx)=>{
    const size = set.size;
    const label = `Girone ${String.fromCharCode(65+idx)} (${size} squadre)`;
    const value = groupKey(set);
    return {label, value, set};
  });

  labeled.forEach(g=>{
    const opt = document.createElement('option');
    opt.value = g.value;
    opt.textContent = g.label;
    groupSelect.appendChild(opt);
  });

  // restore previous choice if possible
  if(previous && labeled.some(g=>g.value===previous)){
    groupSelect.value = previous;
  }

  function renderSelected(){
    const key = groupSelect.value;
    const group = labeled.find(g=>g.value===key);
    if(!group) return;

    const groupTeams = group.set;
    // filter matches only within group
    const groupMatches = groupStage.filter(m=>groupTeams.has(m.s1) && groupTeams.has(m.s2));
    const standings = computeStandings(groupMatches, groupTeams);
    renderStandings(standings);

    const sub = document.getElementById('standingsSub');
    sub.textContent = `Girone selezionato: ${group.label} â€¢ Match considerati: ${groupMatches.length}`;

    renderKnockout(standings, ko);
  }

  groupSelect.onchange = renderSelected;
  renderSelected();
}

document.getElementById('reloadBtn').addEventListener('click', loadAll);
loadAll();
</script>
</body>
</html>
